import sys
from typing import Any, Callable, TYPE_CHECKING, Optional
from types import FrameType

# For static analysis/clarity.
if TYPE_CHECKING:
    TracerFunc = Callable[[FrameType, str, Any], Optional[Callable[..., Any]]]

# Configuration Constant: Name of the variable intended for deletion from frames.
SECRET_VARIABLE_NAME: str = 'my_secret_variable'

# Cache for the tracer function reference.
_tracer: Optional[Callable[[FrameType, str, Any], Optional[Callable[..., Any]]]] = None

def _execution_state_interceptor(frame: FrameType, event: str, arg: Any) -> Optional[Callable[..., Any]]:
    """
    The tracing function registered via sys.settrace().

    Attempts to delete SECRET_VARIABLE_NAME from the current frame's local scope
    on every execution event for immediate cleanup.
    """
    
    # Best practice for efficiency: Direct dictionary deletion on f_locals.
    locals_map = frame.f_locals
    if SECRET_VARIABLE_NAME in locals_map:
        try:
            del locals_map[SECRET_VARIABLE_NAME]
        except RuntimeError:
            # Catches frame modification restrictions (rare, but possible).
            pass

    # The tracer must return a reference to itself to remain active.
    # We rely on the global _tracer being correctly set in activate_interceptor.
    return _tracer  # type: ignore [return-value]


def activate_interceptor() -> None:
    """
    Activates the global Python execution tracing hook using sys.settrace().
    """
    global _tracer
    
    if _tracer is None:
        _tracer = _execution_state_interceptor
        
    try:
        sys.settrace(_tracer)
    except RuntimeError:
        # Silently fail if tracing cannot be set (e.g., security restrictions).
        pass


def deactivate_interceptor() -> None:
    """
    Deactivates the global tracing hook by setting the trace function to None.
    """
    try:
        sys.settrace(None)
    except RuntimeError:
        # Defensive catch for deactivation errors.
        pass


# Module Initialization: Activate tracing immediately upon import.
# Note: Global tracing imposes performance overhead on all interpreted Python code.
activate_interceptor()
