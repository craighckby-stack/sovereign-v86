import sys
from types import FrameType
from typing import Any, Callable, Optional, Final

# --- Configuration ---

# Define the name of the sensitive variable using typing.Final for immutability clarity.
SENSITIVE_VARIABLE_NAME: Final[str] = 'my_secret_variable'

# --- Trace Handler (Performance Critical) ---

def _scrub_handler(
    frame: FrameType, 
    event: str, 
    arg: Any
) -> Optional[Callable]:
    """
    High-performance trace handler executed on every line/event.

    Deletes the sensitive variable from the frame's local scope (f_locals) if present.
    This function is optimized for speed in a high-frequency context.
    """
    # Access locals directly for maximum performance.
    f_locals = frame.f_locals

    # Optimized check and delete block.
    if SENSITIVE_VARIABLE_NAME in f_locals:
        del f_locals[SENSITIVE_VARIABLE_NAME]

    # Must return the function itself to continue tracing the next line/event.
    return _scrub_handler

# --- Context Manager (Readability and Best Practice) ---

class SensitiveVariableScrubber:
    """
    A context manager for safely enabling and disabling system-wide variable scrubbing.
    
    Ensures the original trace function is restored upon exit, adhering to RAII principles.
    
    Usage:
        with SensitiveVariableScrubber():
            # Code where 'my_secret_variable' is automatically scrubbed
            ...
    """
    def __init__(self):
        self._original_trace_fn: Optional[Callable] = None

    def __enter__(self) -> None:
        """Saves the current trace function and installs the scrubber handler."""
        self._original_trace_fn = sys.gettrace()
        
        # Apply the optimized trace handler.
        sys.settrace(_scrub_handler)

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """Restores the system trace function to its original state."""
        # Restore the saved trace function, even if it was None.
        sys.settrace(self._original_trace_fn)
        self._original_trace_fn = None